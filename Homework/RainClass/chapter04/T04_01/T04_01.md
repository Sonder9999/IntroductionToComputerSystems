假设一个C语言程序有两个源文件：main.c和proc1.c，它们的内容:

```c
main.c

1   #include <stdio.h>
2   unsigned x=257;
3   short y, z=2;
4   void proc1(void);
5   void main()
6   {
7      proc1();
8      printf("x=%u, z=%d\n", x, z);
9      return 0;
10  }
```

---

```c
proc1.c
1  double   x;
2
3  void proc1()
4  {
5      x=-1.5;
6  }
```

回答下列问题。

（1）在上述两个文件中出现的符号哪些是强符号？哪些是弱符号？

（2）程序执行后的打印结果是什么？请分别画出执行第7行的proc1()函数调用前、后，在地址&x和&z中存放的内容。若第3行改为“short y=1, z=2;”，打印结果是什么？

（3）修改文件proc1，使得main.c能输出正确的结果（即x=257, z=2）。要求修改时不能改变任何变量的数据类型和名字。

---
## Question1
CSAPP P.471
**强符号: 函数和已初始化的全局变量**
**弱符号: 未初始化的全局变量**

| 函数      | 强符号         | 弱符号      |
| --------- | -------------- | ----------- |
| `main.c`  | `main` `x` `z` | `y` `proc1` |
| `proc1.c` | `x`            | `proc1`     |

---

    为什么在main.c里proc1是弱符号?

在C语言中，函数声明（即函数原型）通常被视为弱符号，因为它们只是告诉编译器函数的存在，而不提供函数的定义。只有函数定义才会被视为强符号。

在你的代码中，`proc1`在`main.c`中只是被声明了，而没有被定义，因此它是一个弱符号。只有在`proc1.c`中定义了`proc1`函数时，它才会成为一个强符号。

---
    为什么x在proc1.c里是弱符号,他不是在proc1函数里定义了吗?

在proc1.c中，x在proc1函数内部被赋值，但这并不意味着它是一个强符号。强符号和弱符号的区分主要在于全局变量和函数的定义。

如果x在proc1.c中是一个全局变量，并且被初始化了，那么它就是一个强符号。如果x只是一个局部变量或者未初始化的全局变量，那么它就是一个弱符号。

根据你提供的代码片段，x看起来像是一个全局变量，但没有显示出它的定义和初始化状态。如果x在proc1.c中是这样定义的：

那么它就是一个强符号。如果它是这样定义的：

那么它就是一个弱符号。

请确认x在proc1.c中的定义方式，以确定它是强符号还是弱符号。

---

## Question2

程序执行后的打印结果为 `x = 0, z = 0`

**小端方式**,`x`最开始为`unsigned`类型,初始化为`257`,转为16进制为`1 01`,小端方式`01 01 00 00`
同理,`z`最开始为`short`类型,初始化为`2`,转为16进制为`02`,小端方式`02 00`
`-1.5`转为`double`类型的机器码为`BFF8 0000 0000 0000`其中`BF F8 00 00`会覆盖`z`,`00 00 00 00`会覆盖`x`


| line         | x值   | x类型      | &x            | z值  | z类型   | &z                  |
| ------------ | ----- | ---------- | ------------- | ---- | ------- | ------------------- |
| `2`          | `257` | `unsigned` | `01 01 00 00` |      |         |                     |
| `3`          | `257` | `unsigned` | `01 01 00 00` | `2`  | `short` | `02 00`             |
| `7`->***1*** | `257` | `unsigned` | `01 01 00 00` | `2`  | `short` | `02 00`             |
| ***5***      | `0`   | `unsigned` | `00 00 00 00` | `0`  | `short` | `00 00 `~~`F8 BF`~~ |



|               | `&x`          | `&z`          |
| ------------- | ------------- | ------------- |
| `proc1`调用前 | `01 01 00 00` | `02 00`       |
| `proc1`调用后 | `00 00 00 00` | `00 00 F8 BF` |

**第三行更改后**

`x = 0, z = -16392`

---

## Question3

```c
static double x;

void proc1()
{
    x = -1.5;
}
```

改为`static double x`即可

---

### Question1

| 函数      | 强符号         | 弱符号      |
| --------- | -------------- | ----------- |
| `main.c`  | `main` `x` `z` | `y` `proc1` |
| `proc1.c` | `x`            | `proc1`     |

### Question2

**程序执行后**打印结果为 `x = 0, z = 0`

**小端方式**,`x`最开始为`unsigned`类型,初始化为`257`,转为16进制为`1 01`,小端方式`01 01 00 00`
同理,`z`最开始为`short`类型,初始化为`2`,转为16进制为`02`,小端方式`02 00`
`-1.5`转为`double`类型的机器码为`BFF8 0000 0000 0000`其中`BF F8 00 00`会覆盖`z`,`00 00 00 00`会覆盖`x`

|               | `&x`          | `&z`          |
| ------------- | ------------- | ------------- |
| `proc1`调用前 | `01 01 00 00` | `02 00`       |
| `proc1`调用后 | `00 00 00 00` | `00 00 F8 BF` |

**第三行更改后** 打印结果为`x = 0, z = -16392`

### Question3

改为第一行的`double x`改为`static double x`即可

```c
static double x;

void proc1()
{
    x = -1.5;
}
```

