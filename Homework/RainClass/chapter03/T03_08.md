CSAPP P.197

```c
char *getline()

{

    char buf [8] ;

    char *result ;

    gets(buf) ;

    result = malloc( strlen (buf) ) ;

    strcpy(result, buf) ;

    return result ;

}

```



```assembly
1   0804840c <getline>:

2   804840c:    55                                push   %ebp

3   804840d:    89  e5                          mov    %esp,%ebp

4   804840f:    83  ec  28                     sub    $0x28,%esp

5   8048412:    89  5d  f4                     mov    %ebx,-0xc(%ebp)

6   8048415:    89  75  f8                     mov    %esi,-0x8(%ebp)

7   8048418:    89  7d  fc                     mov    %edi,-0x4(%ebp)

8   804841b:    8d  75  ec                     lea    -0x14(%ebp),%esi

9   804841e:    89  34  24                     mov    %esi,(%esp)

10  8048421:    e8  a3  ff  ff  ff            call   80483c9 <gets>

```



# GPT

### **(1) 执行第 7 行指令后栈中的信息存放情况**

**第 7 行指令**：`mov %edi,-0x4(%ebp)`
将寄存器 `EDI` 的值保存到栈中 `-0x4(%ebp)` 的位置。

#### **栈布局：**

栈在 `ESP` 上减少了 `0x28` 个字节，且按照汇编的调用规则，从低地址到高地址依次存放局部变量、保存的寄存器值和返回地址。

| 地址         | 内容         | 含义                            |
| ------------ | ------------ | ------------------------------- |
| `0xbffc07f4` | `0x080485c8` | 返回地址 (caller 的下一指令)    |
| `0xbffc07f0` | `0xbffc0800` | 调用者的 `EBP`                  |
| `0xbffc07ec` | `0x5`        | `EBX` 的旧值                    |
| `0xbffc07e8` | `0x10`       | `ESI` 的旧值                    |
| `0xbffc07e4` | `0x8`        | `EDI` 的旧值                    |
| `0xbffc07e0` | -            | 未使用的局部变量空间 (局部变量) |

------

### **(2) 执行第 10 行指令并调用 gets 函数后，回到第 10 行的下一条指令时栈中的信息存放情况**

**第 10 行指令**：`call 80483c9 <gets>`
`gets` 函数读取输入，并存储在 `buf` 对应的内存中。

#### **输入数据 "0123456789 abcdef0123456789\n" 被 gets 写入后：**

| 地址         | 内容                              | 含义                   |
| ------------ | --------------------------------- | ---------------------- |
| `0xbffc07f4` | `0x080485c8`                      | 返回地址               |
| `0xbffc07f0` | `0xbffc0800`                      | 调用者的 `EBP`         |
| `0xbffc07ec` | `0x5`                             | `EBX` 的旧值           |
| `0xbffc07e8` | `0x10`                            | `ESI` 的旧值           |
| `0xbffc07e4` | `0x8`                             | `EDI` 的旧值           |
| `0xbffc07d4` | `"0123456789 abcdef0123456789\0"` | `buf` 内容，覆盖了内存 |

**缓冲区溢出情况**：
输入字符串超出了 `buf` 的大小（8 字节），导致覆盖了 `EBP` 和返回地址等关键数据。

------

### **(3) getline 的 ret 指令：正常返回地址与错误返回地址**

**正常返回地址**：
在 `getline` 的 `ret` 指令执行时，返回地址应为 `0x080485c8`（caller 的下一指令地址）。

**错误返回地址**：
由于缓冲区溢出，`gets` 将输入覆盖了返回地址，实际返回地址被写成了字符串的一部分（如 `"abcdef01"` 对应的地址可能为 `0x61626364`）。这是导致段错误的原因。

------

### **(4) 执行完 gets 函数后，哪些寄存器的内容已被破坏？**

`gets` 函数会：

- 改变寄存器 `EAX`（存储结果指针）。
- 改变寄存器 `ECX` 和 `EDX`（临时使用）。
- 其他寄存器可能在函数调用期间被调用者保存，但需注意缓冲区溢出会破坏栈中的内容，包括保存的 `EBP`。

------

### **(5) 除了缓冲区溢出，getline 的 C 代码还有哪些错误？**

1. **malloc 的大小错误**：
   `malloc(strlen(buf))` 未包含字符串末尾的 `\0`，导致内存分配不足。应改为 `malloc(strlen(buf) + 1)`。
2. **未验证 malloc 成功**：
   `malloc` 返回可能为 `NULL`，应检查返回值是否有效。
3. **未释放内存**：
   返回的指针需要在调用方手动释放，否则会导致内存泄漏。
4. **gets 函数的危险性**：
   `gets` 不会检查输入大小，应改用 `fgets` 限制最大输入长度。

------

### 修正后的安全版本：

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *getline_safe() {
    char buf[8];
    char *result;

    if (!fgets(buf, sizeof(buf), stdin)) {
        return NULL; // 输入失败
    }

    // 去除换行符
    buf[strcspn(buf, "\n")] = '\0';

    // 为字符串分配内存，并包含 '\0'
    result = malloc(strlen(buf) + 1);
    if (!result) {
        perror("malloc failed");
        exit(EXIT_FAILURE);
    }

    strcpy(result, buf);
    return result;
}
```


# Copilot

### (1) 执行第7行指令后栈中的信息存放情况

执行第7行指令后，栈中的信息如下：

| 地址       | 内容       | 含义                  |
| ---------- | ---------- | --------------------- |
| 0xbffc07f0 | 0x80485c8  | 返回地址              |
| 0xbffc07f4 | 0xbffc0800 | 调用者的 EBP          |
| 0xbffc07f8 | 0x5        | 调用者的 EBX          |
| 0xbffc07fc | 0x10       | 调用者的 ESI          |
| 0xbffc0800 | 0x8        | 调用者的 EDI          |
| 0xbffc0804 | 0x804841b  | 局部变量 `buf` 的地址 |

### (2) 执行第10行指令并调用gets函数后回到第10行的下一条指令执行时栈中的信息存放情况

执行第10行指令并调用 `gets` 函数后，栈中的信息如下：

| 地址       | 内容       | 含义                  |
| ---------- | ---------- | --------------------- |
| 0xbffc07f0 | 0x80485c8  | 返回地址              |
| 0xbffc07f4 | 0xbffc0800 | 调用者的 EBP          |
| 0xbffc07f8 | 0x5        | 调用者的 EBX          |
| 0xbffc07fc | 0x10       | 调用者的 ESI          |
| 0xbffc0800 | 0x8        | 调用者的 EDI          |
| 0xbffc0804 | 0x804841b  | 局部变量 `buf` 的地址 |
| 0xbffc0808 | '0'        | `buf` 的内容          |
| 0xbffc0809 | '1'        | `buf` 的内容          |
| 0xbffc080a | '2'        | `buf` 的内容          |
| 0xbffc080b | '3'        | `buf` 的内容          |
| 0xbffc080c | '4'        | `buf` 的内容          |
| 0xbffc080d | '5'        | `buf` 的内容          |
| 0xbffc080e | '6'        | `buf` 的内容          |
| 0xbffc080f | '7'        | `buf` 的内容          |
| 0xbffc0810 | '8'        | `buf` 的内容          |
| 0xbffc0811 | '9'        | `buf` 的内容          |
| 0xbffc0812 | ' '        | `buf` 的内容          |
| 0xbffc0813 | 'a'        | `buf` 的内容          |
| 0xbffc0814 | 'b'        | `buf` 的内容          |
| 0xbffc0815 | 'c'        | `buf` 的内容          |
| 0xbffc0816 | 'd'        | `buf` 的内容          |
| 0xbffc0817 | 'e'        | `buf` 的内容          |
| 0xbffc0818 | 'f'        | `buf` 的内容          |
| 0xbffc0819 | '0'        | `buf` 的内容          |
| 0xbffc081a | '1'        | `buf` 的内容          |
| 0xbffc081b | '2'        | `buf` 的内容          |
| 0xbffc081c | '3'        | `buf` 的内容          |
| 0xbffc081d | '4'        | `buf` 的内容          |
| 0xbffc081e | '5'        | `buf` 的内容          |
| 0xbffc081f | '6'        | `buf` 的内容          |
| 0xbffc0820 | '7'        | `buf` 的内容          |
| 0xbffc0821 | '8'        | `buf` 的内容          |
| 0xbffc0822 | '9'        | `buf` 的内容          |
| 0xbffc0823 | '\n'       | `buf` 的内容          |

### (3) 当执行到getline的ret指令时，假如程序不发生段错误，则正确的返回地址是什么?发生段错误是因为执行getline的ret指令时得到了什么样的返回地址?

- 正确的返回地址应该是 `0x80485c8`。
- 发生段错误是因为执行 `getline` 的 `ret` 指令时，返回地址被 `gets` 函数读取的超长输入覆盖，导致返回地址变成了无效地址。

### (4) 执行完gets函数后，哪些寄存器的内容已被破坏?

- 执行完 `gets` 函数后，`eax`、`ecx` 和 `edx` 寄存器的内容可能已被破坏，因为这些是调用者保存寄存器。

### (5) 除了可能发生缓冲区溢出以外，getline的C代码还有哪些错误?

- `malloc` 的大小应该是 `strlen(buf) + 1`，以确保有足够的空间存储字符串和终止符 `\0`。
- `gets` 函数本身是不安全的，应该使用 `fgets` 或其他安全的输入函数来避免缓冲区溢出。